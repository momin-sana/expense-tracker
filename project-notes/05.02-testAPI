## âœ… Test API Using Thunder Client (or Postman)

With your backend server running, it's time to **test the Auth API** for:

Weâ€™ll do 2 things:

ðŸŸ¢ 1. Register a user
ðŸ”’ 2. Login the user and receive a JWT token


Weâ€™ll use **Thunder Client (VS Code)** for testing (you can also use Postman).

---

## âš¡ A. Install Thunder Client in VS Code

1. Open **VS Code**
2. Go to **Extensions** â†’ search `Thunder Client`
3. Click **Install**
4. Youâ€™ll now see a âš¡ **Thunder icon** in the sidebar

---

ðŸ”¹ STEP A: Register a New User
Request:

Method: POST

URL: http://localhost:5000/api/auth/register

Body (JSON):
{
  "username": "john",
  "email": "john@example.com",
  "password": "123456"
}
Expected Response (if successful):

json
{
  "id": 1,
  "username": "john",
  "email": "john@example.com",
  "password": "$2a$10$...hashedpassword...",
  "updatedAt": "2025-05-13T12:34:56.000Z",
  "createdAt": "2025-05-13T12:34:56.000Z"
}
âœ… At this stage, NO TOKEN is sent yet â€” just user is saved.

ðŸ”¹ STEP B: Login and Get JWT Token
Request:

Method: POST

URL: http://localhost:5000/api/auth/login

Body (JSON):
{
  "email": "john@example.com",
  "password": "123456"
}
Expected Response:

json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "user": {
    "id": 1,
    "username": "john",
    "email": "john@example.com"
  }
}
âœ… This confirms:

Credentials are valid

JWT token is generated with 1-day expiry

You get user info without the password (which is good)

âœ… Why This Is Secure & Clean
Feature	Status
Password hashing with bcrypt	âœ… Yes
JWT token generation at login	âœ… Yes
User creation via Sequelize	âœ… Yes
No .env leakage	âœ… Yes
Only user info (no password) returned to client	âœ… Yes

ðŸ” REMINDER: Your .env Must Contain This
In server/.env:
    DB_NAME=expense_tracker
    DB_USER=root
    DB_PASS=
    DB_HOST=localhost
    JWT_SECRET=your_secret_key_here
If JWT_SECRET is missing or incorrect, the login route will crash. So double-check this.


---

## ðŸ”’ D. What Does the Token Do?

* This `token` must be **saved in `localStorage`** in the frontend
* Itâ€™s included in **Authorization headers** for protected routes

  ```http
  Authorization: Bearer your.jwt.token
  ```

---

## ðŸ§  Auth Controller Code (Final Version)

> âœ… Auto-login on registration
> âœ… Returns token + user
> âœ… Clean, reusable structure

### File: `controllers/authController.js`

```js
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');

// Register (with token)
exports.register = async (req, res) => {
  const { username, email, password } = req.body;
  try {
    const existingUser = await User.findOne({ where: { email } });
    if (existingUser)
      return res.status(400).json({ error: 'Email already exists' });

    const hashed = await bcrypt.hash(password, 10);
    const user = await User.create({ username, email, password: hashed });

    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.status(201).json({
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
      },
    });
  } catch (err) {
    res.status(400).json({ error: err.message });
  }
};

// Login
exports.login = async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ where: { email } });
    if (!user || !(await bcrypt.compare(password, user.password)))
      return res.status(401).json({ error: 'Invalid credentials' });

    const token = jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '1d' });

    res.json({
      token,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
      },
    });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
```

---

## ðŸ§¾ Summary Table

| Task                     | Status        |
| ------------------------ | ------------- |
| Database Setup           | âœ… Completed   |
| Sequelize Models         | âœ… Done        |
| Tables Synced            | âœ… Done        |
| Auth Controller Written  | âœ… Done        |
| API Testing with Thunder | âœ… Tested      |
| JWT Returned on Login    | âœ… Yes         |
| Auto-login on Register   | âœ… Implemented |

---

## ðŸš€ Next Phase: Build Expense API

In the next step, weâ€™ll create:

* Protected route for adding/viewing expenses
* JWT-based authentication middleware
* Connect with React frontend

---

Will Token Be Unique for Each Login?
  Yes. Even for the same user logging in multiple times, each login generates a new token because:

  The jwt.sign() method signs with a timestamp (iat) internally.

  You are doing:

  js
    jwt.sign({ id: user.id }, process.env.JWT_SECRET, { expiresIn: '1d' })
      
  This means:
  The payload ({ id: user.id }) stays the same
  But each token has a different "issued at" timestamp
  So the final token string will be different every time you call login.

  âœ… So yes, every login will return a new and unique JWT token, even if it's the same user.


âœ… WHAT YOUâ€™VE DONE TILL NOW (Backend Phase 1 â€” Auth)
  Step	                                    Status
  MySQL setup via phpMyAdmin	              âœ… Done
  Sequelize connected with .env	            âœ… Done
  users and expenses tables	                âœ… Done
  Register & login routes tested	          âœ… Done
  Passwords hashed with bcrypt	            âœ… Done
  JWT token on login	                      âœ… Done